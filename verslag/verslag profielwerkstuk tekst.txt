doel van het project:
het samenstellen, implementeren, en testen van een systeem dat de bewegingen van objecten simuleert.



In toepassingen als werktuigbouwkunde, constructie, cinematorgrafie en videospellen is het soms gewenst om een simulatie van de natuurwetten te kunnen gebruiken om bijvoorbeeld voorspellingen te kunnen maken over hoe een constructie zich zal gedragen. Bij film en spellen zijn simulaties een uitkomst omdat deze goedkoop zijn en veel vrijheid geven. Er zit echter een duidelijk verschil in de gevraagde eigenschappen van de simulatie voor deze velden; waar de werktuigbouw graag heeft dat simulaties natuurkundig accuraat zijn, maar de computationele kosten niet van groot belang. Cinematografie, en zeker spellen hechten niet zo veel waarde aan preciesie van de simulatie, zo lang deze realistisch overkomt. De computatione kosten zijn echter van groot belang bij spellen omdat computers simpelweg beperkte middelen hebben, welke ook nog verdeeld moeten worden met andere systemen. Onderzoek doen naar methoden om dergelijke natuurkunde te simuleren kan lijden tot nieuwe methoden met nieuwe eigenschappen. Moderne simulatie methoden gekoppelt met krachtige computers kunnen al indrukwekkende resultaten geven, maar er is nog veel te winnen.




Het simuleren van klassieke bewegingen van objecten:
Beweging staat voor de verandering van de positie van een object, dit betekent dat we formules moeten vinden die als eindresultaat een positie geven. 

//draai formules voor krachten en positie om

Klassieke mechanika omschrijft de beweging van objecten. Omdat we bij simuleren geinteresseert zijn in het benaderen van bewegingen van objecten is het vanzelfsprekend dat we van klassieke mechanica gebruik kunnen maken. Klassieke mechanica is met name gebaseerd op de volgende formule:

	Ft = M * a
F: totale kracht (in Newton of N)
M: massa (in Kilogram)
a: versnelling (in m/(s^2))

Om de verandering in positie, acceleratie en snelheid te beschrijven zien we de posietie als een functie van tijd. De afgeleide van deze functie is de snelheid, en de dubbele afgeleide is de acceleratie. Merk op dat de omschrijving van snelheid en acceleratie puur wiskundig is. Met deze wiskunde zijn onder andere de volgende formules te vormen:

Bij constante snelheid:
	S1 = S0 + V * t
S1: eindpositie (in meter of m)
S0: beginpositie (in meter of m)
V: snelheid (in m/s)
t: tijd (in s)

Bij constante acceleratie:
	V1 = V0 + a * t
V1: eindsnelheid (in m/s)
V0: beginsnelheid (in m/s)
a: acceleratie

Bij constante acceleratie:
	S1 = S0 + V0 * t + 1/2 * a * t^2

Dit is alle wiskunde die nodig is voor het belangrijkste gedeelte van de simulator. Voor enkele specifieke problemen (zoals veren en zwaartekracht) worden natuurkundige formules voor speciaal voor die problemen aangehaalt.

//LEG UIT OVER CONSTANTE ACCELERATIE

//verander 'objecten' in 'particles' waar het om enkele puntmassa's gaat
Naast deze formules moet een abstractie gevonden worden voor objecten in de echte wereld, dit zodat het programma objecten op kan slaan, en in staat is ze te manipuleren. Om de simulatie flexibel en wiskundig eenvoudig te houden worden objecten opgeslagen als punt met als atributen: een coordinaat, snelheid en massa. Het gebruiken van een punt is in dit geval handig omdat we hierdoor niet te maken hebben met rotaties, wat de wiskunde flink vermakkelijkt. Om toch objecten met moeilijkere vormen dan punten te kunnen maken kunnen we meerdere punten met elkaar verbinden. In het echt zijn objecten ook gemaakt van groote hoeveelheden zeer kleine, onderling verbonden massas (atomen), dus deze keuze hoeft niet te betekenen dat de simulator onjuiste resultaten geeft. Bovendien zorgt deze manier van het opbouwen van objecten dat interne krachten goed gesimuleert kunnen worden, zo word het bijvoorbeeld mogelijk dat objecten buigen of breken.

voor de rest van het verslag zullen puntmassa's met positie en snelheid als 'particle', meervoud 'particles' aangeduid worden.


Als we nu terugkijken naar de formules die de positie als functie van tijd beschrijven zien we dat we enkele waarden nodig hebben om de nieuwe positie en snelheid van particles te vinden nodig hebben; de vorige positie, de vorige snelheid, en de acceleratie over het tijdsinterval. De vorige positie en de vorige snelheid zijn atributen van de particle die we willen simulen, dus deze zijn al opgeslagen. De acceleratie moet echter nog uitgerekend worden. De formule F = M * a is af te leiden tot de volgende formule die ons de acceleratie geeft:

	a = Ft / M

Om de acceleratie uit te rekenen hebben we dus de totale kracht die op de particle staat nodig, en de massa van de particle. Net zoals de positie en snelheid is de massa een van de atributen van de particle, welke dus al opgeslagen is en alleen nog maar uitgelezen hoeft te worden. Het berekenen van de totale kracht op een particle is simpelweg de som van alle individuele krachten die op de particle werken, opgetelt:

	Ft = F1 + F2 + F3 + F4 + ... + Fn

Resterend is het berekenen van deze individuele krachten.



Krachten:
//verduidelijking van wat krachten zijn voor mensen die er niks van weten
Er zijn verschillende fenomenen die krachten opwekken, bijvoorbeeld:

zwaartekracht, veerkracht, dempkracht, hydraulische en pneumatische druk, wrijving, normaalkracht (de kracht die objecten op elkaar uitoefenen als ze tegen elkaar 'gedrukt' worden), adhesie, cohesie, magnetisme, drijfkracht etc. etc.

Al deze krachten ontstaan op andere manier, hoewel enkele nauw verwant aan elkaar zijn. Voor een aantal van deze krachten zijn formules opgesteld waarmee ze berekend kunnen worden. Zo gelt bij zwaartekracht, veerkracht en dempkracht bijvoorbeeld dat:

Bij constante g:
	Fz = M * g
Fz = zwaartekracht (in N)
g = gravitatie (in m/(s^2))

Bij constante l:
	Fv = k * (l - lr)
Fv = veerkracht (in N)
k = krachtkonstante (in N/m)
l = lengte van de veer (in m)
l = lengte van de veer bij rust (in m)

Bij constante V:
	Fd = -c * V
Fd = dempkracht (in N)
c = dempingsconstante (in Ns/m)


Om de kracht die deze soorten krachten genereren uit te rekenen zijn maar enkele redelijk eenvoudig te vinden parameters nodig: bij zwaartekracht word de massa van de particle gebruikt, en een constante gravitatie. Voor de veerkracht wordt de veerkrachtconstante, een getal dat de rustlengte van de veer bepaalt en de lengte van de veer (die weer met pythagoras berekent kan worden) gebruikt. Krachten zoals deze zijn exact uit te rekenen voor elk moment. Enkele parameters (zoals l, V en g in kleinere mate) veranderen echter continu. Dit betekent dat de simulatie alleen perfect is als lim t -> 0. Dit kan echter niet berijkt worden door de beperkte rekenkracht die computers bieden (t > 0). Gelukkig is het zo dat de fout die hierdoor ontstaat al snel acceptabele vormen aanneemt als t klein genoeg word gemaakt. Bovendien kan t kleiner gemaakt worden door de simulator meer rekenkracht of tijd te bieden, mocht het gewenst zijn.


Het groote probleem zijn echter normaalkracht en verwanten (drijfkracht en hydraulische druk). In tegenstelling tot de andere krachten zijn deze niet exact te berekenen met enkele factoren; ze onstaan namelijk om een correcte staat te handhaven. Dit betekent dat de kracht niet direct gevonden kan worden: eerst moetten alle andere krachten bekent zijn, waarna berekent kan worden welke kracht daar tegenover moet staan om correcte staat te handhaven. Als een object echter onderhevig is aan meerdere normaalkrachten is ook dit logischerwijs niet mogelijk, aangezien beide krachten kennis over de andere nodig hebben om een resultaat te kunnen leveren.

Omdat al bleek dat de krachten gevolg zijn van het handhaven van een correcte staat kunnen we het probleem ook anders aanpakken; na het toepassen van de alle andere krachten vinden we direct een correcte staat, zonder de krachten uit te rekenen. De posities die de particles na deze operatie hebben is de positie van de particles na de t die gesimuleert wordt. De snelheden van de particles na t zijn te berekenen met de vorige positie, vorige stelheid en de tussenliggende tijd t, omdat we uitgaan van een constante a kunnen we V1 berekenen met de volgende formules:

Bij constante a:
	S1 = S0 + V0 * t + 1/2 * a * t^2

Bij constante a:
	V1 = V0 + a * t
V: snelheid (in m/s)
a: acceleratie

We schrijven de eerste formule om naar een formule die a als antwoord geeft:

bij constante a:
	a = 2  * (S1 - S0 - V0 * t) / t^2

Nu kunnen we deze substitueren in de tweede formule, vereenvoudigd geeft dit:

bij constante a:
	V1 = 2 * (S1 - S0) / t - V0	

Om de constraints te kunnen handhaven hebben we eerst een systeem nodig om duidelijk te kunnen bepalen of een staat 'correct' is, en anders wat er niet correct aan is (zodat we weten wat we moeten veranderen). Dit doen we door relaties tussen particles op te stellen die we 'constraints' of 'beperkingen' noemen. Een constraint omschrijft een eigenschap van de staat van de particles die gehandhaaft moet blijven. Een voorbeeld van een constraint is een afstandsconstraint: om te zorgen dat twee particles niet te dicht bij elkaar komen kunnen we bepalen dat de afstand tussen twee particles niet kleiner mag worden dan een bepaalde waarde die voor de constraint bepaald is. Als de afstand kleiner word dan deze waarde beschouwen we de constraint als geschonden. Afstandsconstraints kunnen ook voorkomen in andere vormen, bijvoorbeeld een afstandsconstraint waar de afstand gelijk moet zijn aan een bepaalde waarde. Deze worden gebruikt om de relaties tussen particles in een object vast te stellen, aangezien deze samengedukt mogen worden, maar ook niet uit elkaar getrokken mogen worden.

