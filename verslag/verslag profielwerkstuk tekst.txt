notes:
verander constraint relaxation in constraint projection, aangezien dit de vakterm lijkt te zijn
projection moet veranderd worden gespeculeerde posities simuleren

zorg dat ALLEEN over positie, snelheid of acceleratie en tijdsinterval gesproken word als in S, V, a en t.
zorg ook dat de afkortingen niet in de tekst voorkomen.

verander 'deterministische kracht' in niet-contactkracht
verander 'normaalkracht' op enkele punten in contactkracht, en geef in de uitleg van contactkracht aan dat spankracht hier ook onder kan vallen
//andere naam!!!

controlleer of het nieuwe 0 = vorig, 1 = huidig, 2 = volgend overal goed gebruikt wordt

Berekeningen voor afstandsconstraint in apendix

TITEL!!!
Kerbal physics program

Het simuleren van algemene natuurkundige effecten gebaseerd op klassieke mechanica.

	What I cannot create, I do not understand.
	- Richard Feynman


opbouw:
doel van het project
belang van het doel
aanpak (deelvragen en bronnen)
simulator
resultaten (meetingen van prestaties)



doel van het project:
het samenstellen en testen van een systeem dat de bewegingen van objecten simuleert.


belang van het onderzoek:
Soms is het nuttig om een simulatie van de natuurwetten te kunnen maken. Bijvoorbeeld om voorspellingen te maken over hoe een constructie zich zal gedragen onder bepaalde omstandigheden, voor films om de mogelijkheden te vergroten of juist de kosten te drukken, of bij spellen om de geloofwaardigheid van de spelwereld te vergroten. Helaas bestaat er nog geen simulatiemethode die perfect werkt voor al deze toepassingen in alle situaties, meestal hebben systemen zelfs maar één specialiteit: of ze zijn in staat de krachten en bewegingen in constructies door te rekenen, of ze kunnen de stroming van vloeistoffen goed benaderen, of ze zijn snel genoeg om in spellen gebruikt te worden. Als een boot ontworpen word kan dit betekenen dat er twee verschillende simulaties nodig zijn: een voor de constructie van de boot zelf, en een andere voor de stroming van het water over de romp. Hoewel het soms mogelijk is om de resultaten van de simulatoren met elkaar uit te wisselen is het resultaat vaak ver van perfect of zelfs onbruikbaar. Door onderzoek te doen naar nieuwe simulatietechnieken worden hopelijk nieuwe systemen met nieuwe, betere eigenschappen ontdekt. Ik dit onderzoek heb ik geprobeert een systeem te ontwikkelen dat in staat is om een grote verscheidenheid aan stoffen met onderlinge interactie te simuleren, zonder van de natuurkundige correctheid van het geheel af te doen.


aanpak:

hoofdvraag:
	hoe werkt een systeem dat de bewegingen van objecten simuleert?
	
deelvragen:
	wat betekent 'bewegen'?
	welk gedeelte van bestaande natuurkunde kan gebruikt worden om bewegingen te simuleren?
	hoe hebben anderen het simuleren van bewegingen aangepakt?
	hoe kunnen we dit gebruiken om bewegingen te simuleren?
		bewegingsformules
		krachten
			deterministische krachten
			normaalkrachten
	welke fouten zitten er in de natuurkunde die het systeem gebruikt? (t > 0, E > 0, floating-point precision)
	hoe significant zijn deze fouten?

deelvragen:
wat betekent 'bewegen'?
Bewegen is het veranderen van de posities en rotaties van objecten over tijd.

welk gedeelte van bestaande natuurkunde kan gebruikt worden om bewegingen te simuleren?
Aangezien het bestuderen van bewegingen een belangrijk onderdeel is van natuurkunde kunnen we een aantal inzichten overnemen voor gebruik in de simulator. Het veld van de natuurkunde dat over bewegingen van objecten (onder normale omstandigheden) gaat heet klassieke mechanica.

//zet hier nog een zin die de gegevens mooi introduceert + verander de zinnen in een tabel?
De volgende grootheden en bijbehorende eenheden zijn overgenomen uit het SI:
Positie is een vectorgrootheid, welke over het algemeen aangeduid word met de letter S. De eenheid die we voor positie zullen gebruiken is meter (of afgekort: m).
Tijd wordt als grootheid met de letter t aangeduid, de eenheid voor tijd is seconde (of afgekort: s)
Snelheid is de eerste afgeleide van Positie over tijd, dit betekent dat snelheid net als positie een vectorgrootheid is. De Letter die gebruikt word om de grootheid snelheid aan te duiden is V, en de eenheid is m/s.
Acceleratie is de tweede afgeleide van Positie over tijd, net als positie en snelheid is acceleratie een vectorgrootheid. De letter om acceleratie aan te duiden is a, de eenheid voor snelheid is m/s^2.

Massa is afgekort m, de eenheid is kilogram (of afgekort: kg). De aanduiding voor kracht is F, en de eenheid is Newton (of afgekort: N), kracht is een vectorgrootheid.

Bovendien biedt de klassieke mechanica de volgende formules:
De tweede wet van Newton:

	Ft = m * a
Ft: totale kracht (in N)
m: massa (in kg)
a: acceleratie (in m/s^2)

De derde wet van Newton stelt dat bij elke kracht een andere kracht bestaat welke tegenovergesteld is in richting en gelijk in magnitude. Dit kunnen als volgt noteren:

	F1 = - F2
F1: kracht 1 (in N)
F2: kracht 2 (in N)

Bovendien bestudeert klassieke mechanica de fenomenen die krachten veroorzaken. Zo zijn voor alle bekende soorten krachten duidelijke definities opgesteld, en bij een groot aantal is dan ook een formule gevonden om de kracht te kunnen berekenen.


Hoe hebben anderen het simuleren van bewegingen aangepakt?
Het simuleren van bewegingen is een veel bestudeerd gebied. Er zijn dan ook veel verschillende methoden om natuurkunde te simuleren ontwikkelt met uiteenlopende eigenschappen. 'Real Time Physics Class Notes' geeft een kleine greep uit de methodes voor vaste stoffen die compitutioneel snel genoeg zijn om in 'real-time' gebruikt te kunnen worden. 

Enkele onderdelen zijn vrijwel gelijk bij alle simulatiemethoden. Om tijdsverloop te kunnen simuleren word de tijd opgedeelt in kleine tijdsintervallen. Bij een bekende staat van de te simuleren objecten word een tijdsinterval bepaald die gesimuleert moet worden, waarna de simulator de staat van de objecten na dit tijdsinterval kan benaderen. Deze nieuwe staat kan nu weer gebruikt worden als beginstaat voor een nieuw tijdsinterval.

Een groot aantal simulatoren maken gebruik van krachten, aangezien veel over krachten bekend is en in veel gevallen bruikbaar zijn. Om de krachten te koppelen aan de posities word de tweede wet van Newton gebruikt in de volgende vorm:

	a = Ft / M
a: versnelling (in m/(s^2))
Ft: totale kracht (in Newton of N)
M: massa (in kilogram)

De totale kracht word berekent door de volgende formule:

bij n krachten:
	Ft = F1 + F2 + ... + F(n-1) + Fn
Ft: totale kracht (in N)
Fn: kracht van kracht n (in N)

//GA HIER OP VERDER

De meeste methoden hebben echter een paar grote problemen; aangezien veel methoden voor elk soort stof (vloeistoffen, gassen, vaste objecten en draden/doeken) een andere techniek gebruiken speciaal voor die soort stof is het zeer moeilijk om onderling gedrag tussen verschillende stoffen die in andere categorieën vallen te simuleren. Bovendien geeft deze koppeling over het algemeen een grote natuurkundige fout. Een ander groot probleem zijn normaalkrachtenkrachten, aangezien er geen concrete formule is om normaalkrachten uit te kunnen rekenen.

Deze problemen zijn echter aangepakt door een paar simulatietechnieken die radicaal anders werken dan de de meeste bekende technieken. Het probleem om normaalkrachtenkrachten goed te simuleren is geadresseerd door Thomas Jakobsen in 'Advanced Character Physics'. Om normaalkrachten en andere zeer stijve krachten te simuleren wordt gekozen om niet te proberen de kracht zelf te benaderen, maar juist het resultaat dat de kracht op de posities heeft. De reden hiervoor was dat het resultaat van de simulatie zo veel stabieler wordt, niet om natuurkundige correctheid te berijken. Toch valt er natuurkundig iets te zeggen voor het idee, met enkele aanpassingen blijkt het zelfs zeer geschikt te zijn om op natuurkundig accurate wijze normaalkrachten te simuleren. In het verslag zelf zal toelichting geveven worden over de natuurkundige achtergrond van dit idee.

Om contactkrachten direct op posities uit te oefenen wordt in 'Advanced Character Physics' voorgesteld een Verlet-integratieschema in combinatie met constraints te gebruiken. Verlet-integratie betekent dat de huidige positie, de vorige positie en de tijd tussen deze posities opgeslagen worden (het is gangbaar om de huidige positie en huidige snelheid op te slaan). De snelheid van de particles is toch impliciet opgeslagen aangezien we deze kunnen berekenen met de volgende formule:

bij constante V:
	V = (S1 - S0) / t0
V: snelheid (in m/s)
S1: huidige positie (in m)
S0: vorige positie (in m)
t0: tijdsinterval tussen S0 en S1 (in s)

Om de nieuwe (gespeculeerde) positie uit te rekenen word deze formule samengenomen met de volgende formule:

bij constante a:
	S2 = S1 + V * t1 + 1/2 * a * t1^2
S2: gespeculeerde volgende positie (in m)
S1: huidige positie (in m)
V: snelheid (in m/s)
t1: tijdsinterval tussen S1 en S2 (in s)
a: acceleratie (in m/s^2)

Samengenomen krijgen we de volgende formule:

	S2 = S1 + (S1 - S0) / t0 * t1 + 1/2 * a * t1^2
S2: gespeculeerde volgende positie (in m)
S1: huidige positie (in m)
S0: vorige positie (in m)
t0: tijdsinterval tussen S0 en S1 (in s)
t1: tijdsinterval tussen S1 en S2 (in s)
a: acceleratie (in m/s^2)

Dit verlet-integratieschema is interessant omdat de snelheid impliciet word opgeslagen in de posities. Dit betekent dat we de gespeculeerde volgende posities (S2) aan kunnen passen terwijl de snelheden voor de volgende tijdstap automatisch bijgewerkt worden. Wat belangrijk is om op te merken is dat bij deze methode aangenomen word dat de snelheid constant is, wat niet klopt aangezien acceleraties gebruikt worden. De methode is wiskundig gezien dus niet correct. Later in het verslag zal ik met een oplossing voor dit probleem komen (aan de hand van een aanpassing voorgestelt door andere onderzoekers).

Nu de gespeculeerde volgende positie bekend is kunnen de contactkrachten hierop werken. Omdat we nu niet geinterreseert zijn in acceleraties maar in posities kunnen contactkrachten niet berekend worden zoals krachten normaal berekend worden. Aangezien contactkrachten ontstaan door beperkingen aan de posities van objecten is het het meest voor de hand liggend om normaalkrachten te representeren als voorwaarden aan de posities van objecten. Deze voorwaarden worden 'constraints' genoemd. Om contactkrachten uit te oefenen kijken we welke constraints geschonden zijn, en passen de posities van de objecten simpelweg aan zodat de constraint niet meer geschonden word (dit met respect tot natuurkundige wetten uiteraart). Dit word constraint projection of constraint relaxation genoemd. In de praktijk komen hierbij een aantal moeilijkheden voor, zo kan het verplaatsen van objecten ervoor zorgen dat een andere constraint juist geschonden word. Ook kan het dat twee constraints een object grofweg dezelfde richting in duwen, wat ervoor kan zorgen dat het object te ver weggeduwd word. De details en oplossingen van deze problemen worden later behandeld. Tot dat punt mag de lezer er van uit gaan dat alle constraints tijdens deze stap op natuurkundig correcte wijze opgelost worden.

In 'Position Based Dynamics' wordt het idee van het Verlet-integgraschema overgenomen uit 'Advanced Character Physics', hoewel hier gekozen word om de snelheden van de particles na elke tijdstap uit te rekenen en ze expliciet op te slaan. De resulterende posities zijn identiek aan de resultaten van normale Verlet-integratie, wat ook betekent dat de wiskundig fout nog steeds aanwezig is. Er is gekozen voor het expliciet opslaan van de snelheden omdat dit het mogelijk maakt de snelheden aan te passen zonder de posities te hoeven veranderen. Voor mijn toepassing heeft deze aanpassing nog een voordeel; hierdoor is het namelijk mogelijk om de formules te veranderen zodat het niet meer nodig is om een constante snelheid aan te nemen, wat er voor zorgt dat de eerder beschreven wiskundige fout niet meer aanwezig is.

Ook word een systeem geboden dat gebruikt kan worden om een grote verscheidenheid aan constraints te formuleren en op te lossen. Dit systeem is helaas gemaakt met snelheid en stabiliteit van de simulatie als uitgangspunt, natuurkundige correctheid is hier bewust voor opgeoffert. Dit systeem heb ik hierom niet overgenomen.

In 'Unified Particle Physics for Real-Time Applications' word het systeem uit 'Position Based Dynamics' aangepast met als hoofddoel te zorgen dat het systeem toegepast kan worden op verschillende typen stoffen, zonder dat de simulator voor de verschillende stoffen verschillende subsystemen nodig heeft. Om dit te berijken worden objecten voorgesteld als 'particles' of puntmassa's met onderlinge relaties (constraints bijvoorbeeld). Zo kunnen zowel vaste stoffen, elastische/vervormbare stoffen, vloeistoffen, gassen en doek op dezelfde wijze gesimuleerd worden. Bovendien word de wiskunde vereenvoudigt door het feit dat particles individueel geen rotatie hebben, terwijl rotaties van objecten die bestaan uit onderling verbonden particles nog steeds op natuurkundig correcte manieren gesimuleerd kunnen worden.

De ideeën die ik heb overgenomen zijn de volgende:
	Verlet-integratie met expliciete snelheid
	constraint projection
	objecten representeren door (groepen) particles, waar particles puntmassa's zijn




Het simuleren van bewegingen van objecten:
abstractie voor objecten:
Om iets te hebben om mee te rekenen moet allereerst een abstractie voor objecten gevonden worden. 'Unified Particle Physics for Real-Time Applications' stelt voor om particles te gebruiken, meerdere particles jkunnen met elkaar verbonden om objecten met complexe vormen voor te stellen worden. Dit maakt de simulatie wiskundig eenvoudig en bovendien zeer flexibel, om deze redenen nemen we deze methode over. De particles krijgen bij onze implementatie de volgende attributen: positie, snelheid, acceleratie en massa. Een andere goede eigenschappen van dit systeem is dat objecten op natuurkundig accurate wijze kunnen roteren terwijl de complexe wiskunde en de practische problemen die normaal met rotaties gepaard gaan niet voorkomen. Bovendien kunnen interne krachten (binnen het object) met deze methode goed gesimuleerd worden, zo wordt het bijvoorbeeld mogelijk dat objecten op accurate wijze buigen of breken.


scheiding der krachten:
Omdat verschillende krachten op verschillende manieren ontstaan hebben we alle krachten opgedeeld in twee groepen, de contactkrachten en de niet-contactkrachten. De definitie van contactkrachten is als volgt:

	Contactkrachten zijn krachten die alleen ontstaan door ruimtelijke beperkingen aan de posities van objecten.

Alle andere krachten zijn niet-contactkrachten. De enige contactkracht is de normaalkracht, welke ontstaat om te zorgen dat twee objecten niet dezelfde ruimte innemen (ruimtelijke beperking). Omdat de ruimtelijke beperkingen gehandhaafd moeten blijven blijkt uit de definitie dat contactkrachten een direct effect hebben op de posities van objecten, terwijl alle andere krachten invloed hebben op de snelheden van objecten. Voor alle niet-contactkrachten bestaan concrete formules om de kracht uit te rekenen.

Een uitzondering op deze regel is wrijvingskracht, aangezien dit geen fundamentele kracht is, maar een gevolg is van meerdere soorten krachten op kleine tot zeer kleine schaal. Een van deze krachten is de normaalkracht. Aangezien de formule die normaal gebruikt word om wrijving te benaderen gebruik maakt van de normaalkracht maar zelf een niet-normaalkracht is, kan deze helaas niet goed geimplementeert worden in deze simulator. De simulator is wel in staat de krachten die bij elkaar 'wrijvingskracht' genoemd worden te simuleren, maar door de kleine schaal waarop deze krachten werken zal zeer veel compitutionele kracht vereist zijn om goede resultaten te krijgen.

Een ander bijzonder geval zijn zeer stijve relaties, zoals trekkrachten in vaste objecten. Zeer stijve relaties geven over het algemeen namelijk instabiele resultaten als te weinig compitutionele kracht gebruikt wordt. Als te weinig compitutionele kracht voor handen is kan het nuttig zijn om de relaties als perfect stijf te beschouwen. In dat geval kunnen de relaties namelijk als contactkracht beschouwd kunnen worden, wat stabielere resultaten geeft.


Niet-contactkrachten:
Omdat contactkrachten en niet-contactkrachten op een structureel andere manier werken is het nodig om beide typen krachten te te simuleren op een manier die recht doet aan de wijze waarop de kracht werkt. Niet-contanckrachten kunnen gebruikt worden zoals krachten over het algemeen gebruikt worden; aan de hand van de formules van de niet-contactkrachten en de staat van alle objecten (positie, snelheid en massa) worden de krachten uitgerekent. Dan word voor elke particle de totale niet-contactkracht uitgerekent als som van alle individuele niet-contactkrachten. Dit kan als volgt genoteert worden:

bij n krachten:
	Ft = F1 + F2 + ... + F(n-1) + Fn
Ft: totale kracht (in N)
Fn: kracht van kracht n (in N)

waarna de totale niet-contactkracht in de tweede wet van Newton wordt ingevuld om de acceleratie uit te rekenen:

	a = Ft / M
a: versnelling (in m/(s^2))
Ft: totale kracht (in Newton of N)
M: massa (in kilogram)


contactkrachten:
'Advanced Character Physics' stelt voor om contactkrachten voor te stellen als beperkingen aan de posities van objecten, welke 'constraints' genoemd worden. Om contaactkrachten toe te passen worden de posities van de particles aangepast zodat de constraint gehandhaaft is. De enige (echte) contactkracht is de normaalkracht, hierom zal ik alleen algoritmes geven om de normaalkracht als constraint te implementeren. De naam van de constraint die normaalkrachten voortelt is de afstandsconstraint. Afstandsconstraints definieren de minimale afstand tussen twee particles om niet met elkaar te overlappen.

Als we contraints oplossen is het eerst handig om te kunnen meten in welke mate constraints geschonden zijn. De grootheid die we hiervoor introduceren is 'fout' met als afkorting E (naar error). De eenheid van de fout is kg * m. Voor elke constraint kan berekend worden hoe de individuele particles verplaatst moeten worden om de constraint te handhaven. Aan de hand van deze verplaatsing kan de fout als volgt berekend worden:

Bij n particles:
	E = P[1]m * |P[1]dS| + P[2]m * |P[2]dS| + ...  + P[n-1]m  * |P[n-1]dS| + P[n]m * |P[n]dS|
E: fout van de constraint (in kg*m)
P[n]m: massa van particle n (in kg)
|P[n]dS|: benodigde afstand waarover particle n verplaatst moet worden (in m)

Bij afstandsconstraints gebruiken we het volgende algoritme om de fout te berekenen:

	if (|P[1]S - P[2]S| > d) {
		E = 0
	} else {
		E = 2 * ||P[1]S - P[2]S| - d| * P[1]m / (1 + P[1]m / P[2]m)
	}
E: fout (in m)
d: afstand die de particles minimaal tot elkaar horen te hebben (in m)
P[n]S: positie van particle n (in m)
P[n]m: de massa van particle n (in kg)

In de appendix wordt toegelicht hoe deze formule opgestelt is.

Een normale formule volstaat niet om E uit te rekenen, want eigenlijk zijn er twee verschillende formules om E uit te rekenen; als de onderlinge afstand tussen de particles groter is dan d is de constraint gehandhaafd, en dus is E = 0. Als de onderlinge afstand kleiner is dan d is er wel sprake van een fout, welke berekent wordt met E = 2 * ||P[1]S - P[2]S| - d| * P[1]m / (1 + P[1]m / P[2]m). Merk ook op dat de waarde van E altijd voldoet aan E >= 0.

Nu gaan we proberen te zorgen dat alle constraints gehandhaafd worden. Het is echter belangrijk dat constraints niet en één keer gehandhaafd worden, anders zouden we er namelijk impliciet van uitgegaan worden dat de invloed van constraints op elkaar verwaarloost kan worden. Vaak is het echter zo dat meerdere particles een constraint delen, en dat beide constraints zo veel invloed op elkaar hebben. Om dit probleem op te lossen worden alle constraints meerdere keren gedeeltelijk gehandhaafd. Door het gedeeltelijk handhaven te herhalen word de fout steeds vermindert tot deze de 0 m * kg benadert. Hoe veel een constraint gehandhaafd moet worden wordt gegeven met de volgende formule:

	Er = E * f
Er: hoeveel de fout van de constraint verminderd moet worden (in m*kg)
E: fout van de constraint (in m*kg)
f: factor (zonder eenheid) die voldoet aan 0 < f <= 1

Nu kan de verplaatsing van de particles berekent worden met:

	relativePosition = P[2]S - P[1]S;
	relativeDirection = relativePosition / |relativePosition|
	P[1]dS = -0.5 * relativeDirection  * Er / P[1]m
	P[2]dS = +0.5 * relativeDirection * Er / P[2]m
relativePosition: positie van particle 2 ten opzichte van particle 1 (in m)
relativeDirection: de richting van particle1 naar particle2 (in m)
P[n]S: positie van particle n (in m)
Er: hoeveel de fout van de constraint verminderd moet worden (in m*kg)
P[n]m: de massa van particle n (in kg)

In de appendix wordt toegelicht hoe deze formule opgestelt is.


Bewegingsformules:
Naast de posities van de objecten zijn de snelheden ook verandert door de normaalkrachten, omdat de normaalkrachten alleen de posities beinvloed hebben moeten de snelheden nog aangepast worden. Om dit te berijken gebruikt 'Advanced Character Physics' een Verlet-integgraschema. Wat inhoud dat de volgende positie van objecten wordt uitgerekend met de volgende formule:

	S2 = S1 + (S1 - S0) / t0 * t1 + 1/2 * a * t1^2
S2: gespeculeerde volgende positie (in m)
S1: huidige positie (in m)
S0: vorige positie (in m)
t0: tijdsinterval tussen S0 en S1 (in s)
t1: tijdsinterval tussen S1 en S2 (in s)
a: acceleratie (in m/s^2)

In deze formule staat de acceleratie voor de acceleratie die veroorzaakt wordt door de niet-contactkrachten. Door Verlet-integratie te gebruiken kan is het niet nodig om een snelheid uit te rekenen. Door de gespeculeerde volgende posities uit te rekenen met de bovenstaande formule, en de constraints daarna op deze gespeculeerde posities te projecteren word de resulterende volgende positie uitgerekend. De huidige posities worden de volgende simulatiestap gebruikt als vorige positie, en de resulterende volgende positie wordt gebruikt als huidige positie. In een aantal gevallen is het echter nuttig om tot snelheden te kunnen beschikken. 

In 'Position Based Dynamics' wordt voorgesteld de snelheid expliciet op te slaan. De volgende formules kunnen daarvoor gebruikt worden:

bij constante V:
	V1 = (S1 - S0) / t0
V: huidige snelheid (in m/s)
S1: huidige positie (in m)
S0: vorige positie (in m)
t0: tijdsinterval tussen S0 en S1 (in s)

En de gespeculeerde volgende positie wordt berekent met de volgende bewegingsformule:

bij constante a:
	S2 = S1 + V1 * t1 + 1/2 * a * t1^2
S2: gespeculeerde volgende positie (in m)
S1: huidige positie (in m)
V1: huidigesnelheid (in m/s)
t1: tijdsinterval tussen S1 en S2 (in s)
a: acceleratie (in m/s^2)

Deze twee formules geven exact dezelfde gespeculeerde volgende positie als de formule van het Verlet-integratie geeft. Wat hier snel duidelijk wordt is dat er een wiskundige fout in het spel is, aangezien een constante snelheid aangenomen wordt, maar de aanwezigheid van een acceleratie aangeeft dat dit niet altijd het geval is. De formule om de huidige snelheid uit te rekenen kan omgeschreven worden zodat deze niet meer uit hoeft te gaan van een constante snelheid, dit leidt tot de volgende formule:

bij constante a:
	V1 = 2 * (S1 - S0) / t0 - V0
V1: huidige snelheid (in m/s)
S1: huidige positie (in m)
S0: vorige positie (in m)
t0: tijdsinterval tussen S0 en S1 (in s)
V0: vorige snelheid (in m/s)

De formule voor de gespeculeerde volgende positie blijft het zelfde.


resultaten:
	snelheid van simuleren (real-time ?)
	optimalizaties (?) (multithreaden, gpu acceleratie, cache coherence, bepaalde natuurkundige fout toestaan)
	stabiliteit simulatie
	optimale instellingen (relaxationCoeficient, fullIterations, relaxationIterations)
	fouten (t > 0, E > 0, floating-point precision) -> geloofwaardigheid & natuurkundige precisie



Appendix:

Berekeningen voor afstandsconstraint:

Broncode voor het testen van de resultaten:
https://github.com/Failsnail/PositionBasedPhysics



Referenties:

Jakobsen T. 2001, 'Advanced Character Physics', www.gamasutra.com
http://www.cs.cmu.edu/afs/cs/academic/class/15462-s13/www/lec_slides/Jakobsen.pdf

Müller M., Heidelberger B., Hennix M., Ratcliff J., 2006, 'Position Based Dynamics', Proceedings of Virtual Reality Interactions and Physical Simulations (VRIPhys), pp 71-80, Madrid, November 6-7
http://matthias-mueller-fischer.ch/publications/posBasedDyn.pdf

Macklin M., Müller M., Chentanez N., Kim T., 2014, 'Unified Particle Physics for Real-Time Applications', ACM Transactions on Graphics (SIGGRAPH 2014), 33(4)
http://mmacklin.com/uppfrta_preprint.pdf

Müller M., Stam J., James D., Thürey N., 2008, 'Real Time Physics Class Notes', ACM SIGGRAPH 2008 classes Article No. 88 
http://matthias-mueller-fischer.ch/realtimephysics/coursenotes.pdf





---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------







Met deze theorie zijn onder andere de volgende formules te vormen:

Bij constante acceleratie:
	V2 = V1 + a * t
V2: volgende snelheid (in m/s)
V1: huidige snelheid (in m/s)
a: acceleratie (in m/s^2)
t: tijdsinterval (in s)

Bij constante a:
	S2 = S1 + V1 * t + 1/2 * a * t^2
S2: volgende positie (in m)
S1: huidige positie (in m)
V1: huidige snelheid (in m/s)
t: tijdsinterval (in s)
a: acceleratie (in m/s^2)

Met deze formules kunnen we een nieuwe positie en snelheid uitrekenen na een tijdsinterval. De nieuwe posities en snelheden worden bij de particles in kwestie opgeslagen, en worden het tijdsinterval daarna gebruikt als de vorige positie en vorige snelheid. De twee onbekenden die overblijven om dit uit te kunnen rekenen zijn de acceleratie en de tijdsinterval. t staat voor de tijd die is verstreken over het interval dat we willen simuleren. Bij applicaties waar de duur van het simuleren ten opzichte van de tijd die in de simulatie verstrijkt niet van groot belang is (bij het berekenen van constructies, of voor films) kan handmatig op een bepaalde waarde vastgesteld worden. Als de tijdsverloop in de simulatie wel bepaald moet worden aan de hand van de tijdsverloop in het echt (zoals bij spellen, waar de tijd buiten en in het spel gelijk moet lopen) kan t dynamisch berekend worden met de volgende formule:

	t = t1 - t0
t: tijdsinterval (in s)
t1: tijd voor huidige simulatie (in s)
t0: tijd voor vorige simulatie (in s)


De andere onbekende, a, kan berekend worden met de tweede wet van Newton:

	a = Ft / M
a: versnelling (in m/(s^2))
Ft: totale kracht (in Newton of N)
M: massa (in kilogram)

Deze wet verbind alle krachten en massa's in ons systeem met de acceleratie, zo is deze wet van onschatbare waarde. Er is hiermee echter een belangrijk probleem: de krachten, massa's en dus ook de acceleratie zijn momentopnamen, maar de acceleratie moet later gebruikt worden op een tijdsinterval. Dit betekent dat we voor de berekeningen verplicht zijn aan te nemen dat a constant is over t, terwijl dit in het echt niet het geval hoeft te zijn.

Om te zorgen dat a zo min mogelijk 'veroudert' proberen we t zo klein mogelijk te maken (liefst zelfs gelijk aan 0), maar anderzijds mag t niet gelijk zijn aan 0, want in dat geval zou geen tijd verstrijken en krijgen we geen resultaat. Wiskundig betekent dit dat de simulatie perfect is als lim t-> 0, wat in essentie betekent dat t gelijk is aan 0, maar dat de berekeningen zich niet gedragen alsof er geen tijd verstrijkt. Omdat we dit niet kunnen bereiken kunnen de resultaten van de simulatie logischerwijs niet perfect zijn. Om het beste resultaat te krijgen moeten we lim t -> benaderen. Dit kan door t zo klein te maken als mogelijk.


De formule om de acceleratie mee uit te rekenen heeft de totale kracht die op de particle staat, en de massa van de particle nodig. Net zoals de positie en snelheid is de massa een van de attributen van de particles, deze is dus opgeslagen en hoeft alleen gelezen te worden. Het berekenen van de totale kracht op een particle is simpelweg de som van alle individuele krachten die op de particle werken:

bij n krachten:
	Ft = F1 + F2 + ... + F(n-1) + Fn
Ft: totale kracht (in N)
Fn: kracht van kracht n (in N)


Resterend is het berekenen van deze individuele krachten. Er zijn verschillende fenomenen die krachten opwekken, bijvoorbeeld:

zwaartekracht, veerkracht, dempkracht, hydraulische en pneumatische druk, wrijving, normaalkracht, adhesie, cohesie, magnetisme, drijfkracht etc. etc.

Al deze krachten ontstaan op andere manier, hoewel enkele nauw verwant aan elkaar zijn. Voor een aantal van deze krachten zijn formules opgesteld waarmee ze berekend kunnen worden. Zo geldt bij zwaartekracht, veerkracht en dempkracht bijvoorbeeld dat:

zwaartekracht:

Bij constante g:
	Fz = M * g
Fz = zwaartekracht (in N)
M: massa (in kilogram)
g = gravitatie (in m/(s^2))

veerkracht:

Bij constante l:
	Fv = k * (l - lr)
Fv = veerkracht (in N)
k = krachtconstante (in N/m)
l = lengte van de veer (in m)
lr = lengte van de veer bij rust (in m)

dempkracht:

Bij constante V:
	Fd = -c * V
Fd = dempkracht (in N)
c = dempingconstante (in Ns/m)
V: snelheid (in m/s)


Om de kracht die deze soorten krachten genereren uit te rekenen zijn maar enkele redelijk eenvoudig te vinden parameters nodig: bij zwaartekracht word de massa van de particle gebruikt, en een constante gravitatie. Voor de veerkracht wordt de veerkrachtconstante, een getal dat de rustlengte van de veer bepaalt en de lengte van de veer (die weer met pythagoras en de posities berekent kan worden) gebruikt. Krachten zoals deze zijn exact uit te rekenen voor elk moment. Omdat deze krachten (binnen de limieten van computers) exact uitgerekend kunnen worden met alleen bekende variabelen zullen deze krachten voor de rest van dit artikel 'deterministische krachten' genoemd worden.


Normaalkracht en verwante krachten (zoals hydraulische druk en drijfkracht) zijn echter niet deterministisch. Deze soort krachten ontstaan namelijk om een correcte staat te handhaven (meerdere objecten mogen niet de zelfde ruimte innemen bijvoorbeeld). Dit betekent dat de kracht niet direct gevonden kan worden: eerst moeten alle andere krachten bekend zijn, waarna berekent kan worden welke kracht daar tegenover gezet moet worden om een correcte staat te handhaven. Als een object echter onderhevig is het exact uitrekenen van de krachten logischerwijs niet mogelijk aangezien beide krachten kennis over de andere nodig hebben om een volledig resultaat te kunnen leveren.

Omdat al bleek dat de krachten het gevolg zijn van het handhaven van een correcte staat kunnen we het probleem ook anders aanpakken; Eerst verplaatsten we de particles door alle 'deterministische krachten' en de beginsnelheid toe te passen (dit noemen we projecteren projecteren). Daarna benaderen we een correcte staat zonder de normaalkrachten uit te rekenen. De posities die de particles na deze operatie hebben is resultaat van zowel de deterministische krachten als van de normaalkrachten, dus gelijk aan de eindpositie (S2). Omdat we uitgaan van een constante a kunnen we V2 berekenen met de volgende formules:

Bij constante a:
	S2 = S1 + V1 * t + 1/2 * a * t^2
S2: volgende positie (in m)
S1: huidige positie (in m)
V1: huidige snelheid (in m/s)
t: tijdsinterval (in s)
a: acceleratie (in m/s^2)

Bij constante a:
	V2 = V1 + a * t
V2: volgende snelheid (in m/s)
V1: huidige snelheid (in m/s)
a: acceleratie (in m/s^2)
t: tijdsinterval (in s)

We schrijven de eerste formule om naar een formule die a als resultaat geeft:

bij constante a:
	a = 2  * (S2 - S1 - V1 * t) / t^2
a: acceleratie (in m/s^2)
S2: volgende positie (in m)
S1: huidige positie (in m)
V1: huidige snelheid (in m/s)
t: tijdsinterval (in s)

Nu kunnen we deze substitueren in de tweede formule, na vereenvoudiging geeft dit:

bij constante a:
	V2 = 2 * (S2 - S1) / t - V1
V2: volgende snelheid (in m/s)
S2: volgende positie (in m)
S1: huidige positie (in m)
t: tijdsinterval (in s)
V1: huidige snelheid (in m/s)

Dit betekent dat we S2 en V2 uit kunnen rekenen zonder dat de acceleratie bekend hoeft te zijn, zolang we de eindpositie (S2) kunnen benaderen.

Om de normaalkrachten te kunnen handhaven hebben we eerst een systeem nodig om duidelijk te kunnen bepalen of een staat 'correct' is (dit systeem is gescheiden van het systeem dat de deterministische krachten beschrijft). Dit doen we door relaties tussen particles op te stellen die we 'constraints' of 'beperkingen' noemen. Een constraint omschrijft een eigenschap van de staat van de particles die gehandhaafd moet blijven. Een voorbeeld van een constraint is een afstandsconstraint: om te zorgen dat twee particles niet te dicht bij elkaar komen kunnen we bepalen dat de afstand tussen twee particles niet kleiner mag worden dan een bepaalde waarde die voor de constraint bepaald is. Als de afstand kleiner wordt dan deze waarde beschouwen we de constraint als geschonden. Afstandsconstraints kunnen ook voorkomen in andere vormen, bijvoorbeeld een afstandsconstraint waar de afstand gelijk moet zijn aan een bepaalde waarde. Deze worden gebruikt om de relaties tussen particles in een object vast te stellen, aangezien deze samengedrukt mogen worden, maar ook niet uit elkaar getrokken mogen worden.

Om dit probleem goed op te lossen is het praktisch om uit te kunnen rekenen hoe 'incorrect' een bepaalde staat is. Als we de constraints op willen lossen proberen we deze waarde dus te verlagen. We definiëren de fout (E) van een constraint als de massa van de particles maal de afstand die deze particles af moeten leggen om de constraint te handhaven:

Bij n particles:
	E = P[1]m * P[1]dS+ P[2]m * P[2]dS + ...  + P[n-1]m  * P[n-1]dS + P[n]m * P[n]dS
E: fout (in kg*m)
P[n]m: massa van particle n (in kg)
P[n]dS: benodigde verandering van positie van particle n (in m)


Omdat er veel verschillende soorten constraints mogelijk zijn is het helaas niet mogelijk om een alomvattende algoritme (formules volstaan niet om deze waarden uit te rekenen) te geven die de fout van een constraint levert. Toch zal ik ter illustratie zal ik een voorbeeld geven; een algoritme die de fout geeft van een afstandsconstraint waar de afstand tussen twee particles exact gelijk moet zijn aan de waarde d:

	E = 2 * ||P[1]S - P[2]S| - d| * P[1]m / (1 + P[1]m / P[2]m)
E: fout (in m)
d: afstand die de particles minimaal tot elkaar horen te hebben (in m)
P[n]S: positie van particle n (in m)
P[n]m: de massa van particle n (in kg)

//leg ook P[1]m * P[1]dS = P[2]m * P[2]dS uit (hoe de formule is opgesteld)? <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Het volgende algoritme geeft de fout voor een afstandsconstraint waar de afstand tussen twee particles groter moet zijn dan de waarde d:

	if (|P[1]S - P[2]S| > d) {
		E = 0
	} else {
		E = 2 * ||P[1]S - P[2]S| - d| * P[1]m / (1 + P[1]m / P[2]m)
	}
E: fout (in m)
d: afstand die de particles minimaal tot elkaar horen te hebben (in m)
P[n]S: positie van particle n (in m)
P[n]m: de massa van particle n (in kg)

Aan dit voorbeeld is goed te zien waarom een normale formule niet altijd volstaat om E uit te rekenen; zolang de onderlinge afstand tussen de particles groter is dan d is de constraint gehandhaafd, en is het resultaat 0 (want er is geen fout). Als de onderlinge afstand echter kleiner is dan d is er wel sprake van een fout. Merk ook op dat de waarde van E altijd voldoet aan E >= 0.

Nu gaan we proberen te zorgen dat alle constraints gehandhaafd worden. Het is echter belangrijk dat constraints niet en één keer gehandhaafd worden, anders zouden we er namelijk impliciet van uitgegaan worden dat de invloed van constraints op elkaar verwaarloost kan worden. Vaak is het echter zo dat meerdere particles een constraint delen, en dat beide zo constraints veel invloed op elkaar hebben. Om dit probleem op te lossen worden alle constraints gedeeltelijk gehandhaafd, door het gedeeltelijk handhaven te herhalen word de fout steeds vermindert. Om te zorgen dat alle constraints evenveel prioriteit krijgen word de fout van een constraint vermenigvuldigd met een factor (f) die voor alle constraints gelijk is, om te bepalen hoever een constraint opgelost moet worden:

//vertel ook over lim E -> 0 ? <<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	Er = E * f
Er: hoeveel de fout van de constraint verminderd moet worden (in m*kg)
E: fout van de constraint (in m*kg)
f: factor (zonder eenheid) die voldoet aan 0 < f <= 1

Nu kan de verplaatsing van de particles berekent worden met:

	relativePosition = P[2]S - P[1]S;
	relativeDirection = relativePosition / |relativePosition|
	P[1]dS = -0.5 * relativeDirection  * Er / P[1]m
	P[2]dS = +0.5 * relativeDirection * Er / P[2]m
relativePosition: positie van particle 2 ten opzichte van particle 1 (in m)
relativeDirection: de richting van particle1 naar particle2 (in m)
P[n]S: positie van particle n (in m)
Er: hoeveel de fout van de constraint verminderd moet worden (in m*kg)
P[n]m: de massa van particle n (in kg)

//Merk dat bij het opstellen van dit algoritme gebruik gemaakt is van de wetten F = M * a ^ F1 = -F2 ^ Sdelta = 1/2 * a * t^2. Deze wetten worden dus door de constraint toegepast.
