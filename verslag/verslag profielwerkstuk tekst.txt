notes:
verander het verslag zelf om minder uitleg te geven over hoe alles in elkaar zit; verplaats deze uitleg naar de aanpak. Zorg dat het verslag een beknopte, duidelijke uitleg is voor mensen die WEL voorkennis hebben, de rest is voor mensen zonder voorkennis.

verander constraint relaxation in constraint projection, aangezien dit de vakterm lijkt te zijn
projection moet veranderd worden in ???-integration


opbouw:
doel van het project
belang van het doel
aanpak (deelvragen en bronnen)
simulator
resultaten (meetingen van prestaties)



doel van het project:
het samenstellen en testen van een systeem dat de bewegingen van objecten simuleert.


belang van het onderzoek:
In toepassingen als werktuigbouwkunde, constructie, cinematografie en videospellen is het soms gewenst om een simulatie van de natuurwetten te kunnen gebruiken om bijvoorbeeld voorspellingen te kunnen maken over hoe een constructie zich zal gedragen. Bij film en spellen zijn simulaties een uitkomst omdat deze goedkoop zijn en veel vrijheid geven. Er zit echter een duidelijk verschil in de gevraagde eigenschappen van de simulatie voor deze velden; waar de werktuigbouw graag heeft dat simulaties natuurkundig accuraat zijn, maar de computationele kosten niet van groot belang. Cinematografie, en zeker spellen hechten niet zo veel waarde aan precisie van de simulatie, zo lang deze realistisch overkomt. De computatione kosten zijn echter van groot belang bij spellen omdat computers simpelweg beperkte middelen hebben, welke ook nog verdeeld moeten worden met andere systemen. Onderzoek doen naar methoden om dergelijke natuurkunde te simuleren kan leiden tot nieuwe methoden met nieuwe eigenschappen. Moderne simulatiemethoden gekoppeld met krachtige computers kunnen al indrukwekkende resultaten geven, maar er is nog veel te winnen.


aanpak:
Jacobsen:
http://www.cs.cmu.edu/afs/cs/academic/class/15462-s13/www/lec_slides/Jakobsen.pdf
position based dynamics:
http://matthias-mueller-fischer.ch/publications/posBasedDyn.pdf
Unified Particle Physics for Real-Time Applications:
http://mmacklin.com/uppfrta_preprint.pdf
Real Time Physics Class Notes:
http://matthias-mueller-fischer.ch/realtimephysics/coursenotes.pdf

hoofdvraag:
	hoe werkt een systeem dat de bewegingen van objecten simuleert?
	
deelvragen:
	wat betekent 'bewegen'?
	welk gedeelte van bestaande natuurkunde kan gebruikt worden om bewegingen te simuleren?
	hoe kunnen we dit gebruiken om bewegingen te simuleren?
		bewegingsformules
		krachten
			deterministische krachten
			normaalkrachten
	welke fouten zitten er in de natuurkunde die het systeem gebruikt? (t > 0, E > 0, floating-point precision)
	hoe significant zijn deze fouten?

deelvragen:
wat betekent 'bewegen'?
Bewegen is het veranderen van de posities en rotaties van objecten over tijd.

welk gedeelte van bestaande natuurkunde kan gebruikt worden om bewegingen te simuleren?
De klassieke mechanica is een veld binnen de natuurkunde dat de bewegingen van objecten bestudeert. Dit veld van de natuurkunde biedt de volgende inzichten:
Positie is een vectorgrootheid, deze word over het algemeen aangeduid met de letter S. De eenheid die we voor positie zullen gebruiken is meter (of afgekort: m).
Tijd is een grootheid die XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX. De letter voor de grootheid tijd is t, de eenheid is seconde (of afgekort: s)
Snelheid is de eerste afgeleide van Positie over tijd, dit zorgt er voor dat snelheid net als positie een vectorgrootheid is. De Letter die gebruikt word om de grootheid snelheid aan te duiden is V, en de eenheid is m/s.
Acceleratie is de tweede afgeleide van Positie over tijd, hierdoor geld net als voor snelheid dat acceleratie een vectorgrootheid is. De letter om acceleratie aan te duiden is a, de eenheid voor snelheid is m/s^2.

Verder biedt klassieke mechanica de grootheden massa en kracht. De aanduiding voor massa is m, en de eenheid is kilogram (of afgekort: kg). De aanduiding voor kracht is F, en de eenheid is Newton (of afgekort: N), kracht is een vectorgrootheid.
Er word van de lezer verwacht enige voorkennis over deze begrippen te hebben.
De tweede wet van Newton stelt het volgende:

	Ft = m * a

De derde wet van Newton stelt dat bij elke kracht een andere kracht bestaat welke tegenovergesteld is in richting en gelijk in magnitude. Dit kunnen we noteren als:

	F1 = - F2

Bovendien bestudeert klassieke mechanica het veroorzaken van krachten. Zo zijn voor alle bekende krachten duidelijke definities opgesteld, en bij een groot aantal is een formule gevonden om de kracht uit te kunnen rekenen.
//VERDER OVER (NORMAAl-)KRACHTEN!!!


Hoe hebben anderen het simuleren van bewegingen aangepakt?
//maak dit duidelijker of maak duidelijk dat meer kennis over het onderwerp nodig is om alles goed te begrijpen
Het simuleren van bewegingen onder invloed van natuurkunde is een veel bestudeerd gebied. Veel verschillende methoden om natuurkunde te simuleren zijn ontwikkelt (zie Real Time Physics Class Notes), elke met andere eigenschappen. De meeste methoden hebben echter een paar grote problemen; aangezien veel methoden voor elk soort stof (vloeistoffen, gassen, vaste objecten en draden/doeken) een andere techniek gebruiken speciaal voor die soort stof is het zeer moeilijk om het gedrag tussen stoffen die in andere categorien vallen te berekenen. Bovendien geeft dit over het algemeen een natuurkundige fout. Een ander groot probleem zijn normaalkrachten aangezien simulatoren over het algemeen gebruik maken van snelheden en acceleraties, maar normaalkrachten direct uitwerken op posities.

Deze problemen zijn echter aangepakt door een paar simulatietechnieken die radicaal anders werken dan de gebruikelijke technieken. Het tweede punt is geaddresseerd door Thomas Jakobsen in 'Advanced Character Physics'. Om het mogelijk te maken om normaalkrachten direct op posities uit te oefenen gebruikt hij een Verlet-integratie schema, wat betekent dat in plaats van de positie en snelheid de positie en de vorige positie opgeslagen worden samen met de verstreken tijd tussen deze twee posities. De snelheid van de particles is impliciet opgeslagen aangezien we deze kunnen uitrekenen met de volgende formule:

bij constante V:
	V = (S1 - S0) / t0
	

Om de nieuwe positie uit te rekenen word deze formule samengenomen met de volgende formule:

	S2 = S1 + V * t1 + a * t1 * t1
	
Merk op dat de acceleratie volgens de bewegingsformules met 1/2 vermenigvuldigd moet worden, wat in dit geval niet gebeurt. Hieronder zal uitgelegt worden waarom dit niet gebeurt. Samengenomen krijgen we de volgende formule:

	S2 = S1 + (S1 - S0) / t0 * t1 + a * t1 * t1

Deze methode om nieuwe posities uit te rekenen wordt Verlet-integration genoemt. Dit systeem is interessant doordat de snelheid impliciet word opgeslagen door de posities aangezien dit betekent dat we de huidige posities aan kunnen passen (om normaalkrachten te handhaven), terwijl de snelheden automatisch bijgewerkt worden. Wat belangrijk is om op te merken is dat bij deze methode aangenomen word dat V constant is, echter worden acceleraties gebruikt, dus V is niet constant, dus wiskundig gezien is de methode niet correct. Gelukkig is dit probleem redelijk eenvoudig op te lossen, zoals gedaan werd door andere onderzoekers.

//CONSTRAINT PROJECTION!!!

In 'Position Based Dynamics' wordt het idee van het Verlet-integration scheme overgenomen, hoewel hier gekozen word om na elke simulatiestap de snelheden van de particles uit te rekenen, om ze expliciet op te slaan. Als de nieuwe gespeculeerde posities berekend worden word deze snelheid gebruikt met de vorige positie, het resultaat is identiek aan Verlet-integratie. De reden dat de onderzoekers deze keuze maakten was vooral dat het in bepaalde gevallen handig was om de snelheid direct te kunnen gebruiken of manipuleren. Voor mijn toepassing heeft dit echter nog een ander voordeel; hierdoor is het namelijk mogelijk om de formules te veranderen zodat het niet meer nodig is om uit te gaan van constante snelheid, later ga ik verder in op de formules die ik gebruikt heb.

//introduceer de toevoegingen van position based dynamics (opslaan van snelheden ipv. verlet integration)

//Leg uit hoe nvidia flex puntmassa's gebruikt om rotaties te omzeilen en om te zorgen dat alle objecten binnen één representatie vallen.

hoe kunnen we dit gebruiken om bewegingen te simuleren?	//NEENEENEENEE, dit hoort pas in het verslag!
Omdat snelheid en acceleratie puur wiskundig gedefinieert zijn mogen we wiskunde over afgeleiden en primitiven op deze grootheden loslaten. Als we de verandering van V over t berekenen aan de hand van a geeft dit:

	V1 = V0 + a * t
als a constant is.

Als we deze formule weer gebruiken om de verandering van P over t te beschrijven krijgen we:

	S1 = S0 + V0 * t + 1/2 * a * t^2
als a constant is.

Nu weten we hoe we S en V uit moeten rekenen. Het berekenen van a gebeurt met krachten.

krachten:
Zoals eerder vermeld bestaat in de klassieke mechanica de volgende formule:

	Ft = m * a

Om a uit te rekenen schrijven we deze om naar:

	a = m / Ft


//GA IK DIT ECHT TWEE KEER BEHANDELEN?!?


deterministische krachten
normaalkrachten
welke fouten zitten er in de natuurkunde die het systeem gebruikt? (t > 0, E > 0, floating-point precision)
hoe significant zijn deze fouten?

resultaten:
	snelheid van simuleren (real-time ?)
	optimalizaties (?) (multithreaden, gpu acceleratie, cache coherence, bepaalde natuurkundige fout toestaan)
	stabiliteit simulatie
	optimale instellingen (relaxationCoeficient, fullIterations, relaxationIterations)
	fouten -> geloofwaardigheid













het simuleren van bewegingen van objecten:
Om iets te hebben om mee te rekenen moet allereerst een abstractie voor objecten gevonden worden. Om de simulatie flexibel en wiskundig eenvoudig te houden worden objecten opgeslagen als punt met als attributen: een positie, snelheid en massa, deze punten worden 'particle', meervoud 'particles' genoemd. Om toch objecten met vormen moeilijkere dan punten te kunnen gebruiken kunnen we meerdere punten met elkaar verbinden (later in het verslag wordt hier verder op ingegaan). Een paar handige eigenschappen van dit systeem is dat objecten op natuurkundig accurate wijze kunnen roteren zonder dat alle wiskunde die hier normaal aan verbonden zijn vereist is. Bovendien kunnen interne krachten (binnen het object) goed gesimuleerd worden, zo wordt het bijvoorbeeld mogelijk dat objecten buigen of breken.

Beweging staat voor de verandering van de positie van een object. Het ultieme doel van de simulator is het vinden van nieuwe posities na een bepaald tijdsinterval (t). Om de verandering in positie te kunnen beschrijven zien we de positie (S) als een functie van tijd (t). De afgeleide van deze functie is de snelheid (V), en de dubbele afgeleide is de acceleratie (a). Merk op dat de omschrijving van snelheid en acceleratie puur wiskundig is. Met deze theorie zijn onder andere de volgende formules te vormen:

Bij constante a:
	S1 = S0 + V0 * t + 1/2 * a * t^2
S1: huidige positie (in m)
S0: vorige positie (in m)
V0: vorige snelheid (in m/s)
t: tijdsinterval (in s)
a: acceleratie (in m/s^2)

Bij constante acceleratie:
	V1 = V0 + a * t
V1: huidige snelheid (in m/s)
V0: vorige snelheid (in m/s)
a: acceleratie (in m/s^2)
t: tijdsinterval (in s)

Met deze formules kunnen we een nieuwe positie en snelheid uitrekenen. De nieuwe posities en snelheden worden bij de particles opgeslagen, en worden de keer daarop gebruikt voor de vorige positie en vorige snelheid. De twee onbekenden die overblijven om dit uit te kunnen rekenen zijn a en t. t staat voor de tijd die is verstreken over het interval dat we willen simuleren. Bij applicaties waar de duur van het simuleren ten opzichte van de tijd die in de simulatie verstrijkt niet van groot belang is (bij het berekenen van constructies, of voor films) kan handmatig op een bepaalde waarde vastgesteld worden. Als de tijdverloop in de simulatie wel bepaald moet worden aan de hand van de tijdverloop in het echt (zoals bij spellen, waar de tijd buiten en in het spel gelijk moet lopen) kan t dynamisch berekend worden met de volgende formule:

	t = t1 - t0
t: tijdsinterval (in s)
t1: huidige tijd (in s)
t0: vorige tijd (in s)


De andere onbekende, a, kan berekend worden met de tweede wet van Newton:

	a = Ft / M
a: versnelling (in m/(s^2))
Ft: totale kracht (in Newton of N)
M: massa (in kilogram)

Deze wet verbind alle krachten en massa's in ons systeem met de acceleratie, zo is deze wet van onschatbare waarde. Er is hiermee echter een belangrijk probleem: de krachten, massa's en dus ook de acceleratie zijn momentopnamen, maar de acceleratie moet later gebruikt worden op een tijdsinterval. Dit betekent dat we voor de berekeningen verplicht zijn aan te nemen dat a constant is over t, terwijl dit in het echt niet het geval hoeft te zijn.

Om te zorgen dat a zo min mogelijk 'veroudert' proberen we t zo klein mogelijk te maken (liefst zelfs gelijk aan 0), maar anderzijts mag t niet gelijk zijn aan 0, want in dat geval zou geen tijd verstrijken en krijgen we geen resultaat. Wiskudig betekent dit dat de simulatie perfect is als lim t-> 0, wat in essentie betekent dat t gelijk is aan 0, maar dat de berekeningen zich niet gedragen alsof er geen tijd verstrijkt. Omdat we dit niet kunnen berijken kunnen de resultaten van de simulatie logischerwijs niet perfect zijn. Om het beste resultaat te krijgen moeten we lim t -> benaderen. Dit kan door t zo klein te maken als mogelijk.


De formule om de acceleratie mee uit te rekenen heeft de totale kracht die op de particle staat, en de massa van de particle nodig. Net zoals de positie en snelheid is de massa een van de attributen van de particles, deze is dus opgeslagen en hoeft alleen gelezen te worden. Het berekenen van de totale kracht op een particle is simpelweg de som van alle individuele krachten die op de particle werken:

bij n krachten:
	Ft = F1 + F2 + ... + F(n-1) + Fn
Ft: totale kracht (in N)
Fn: kracht van kracht n (in N)


Resterend is het berekenen van deze individuele krachten. Er zijn verschillende fenomenen die krachten opwekken, bijvoorbeeld:

zwaartekracht, veerkracht, dempkracht, hydraulische en pneumatische druk, wrijving, normaalkracht, adhesie, cohesie, magnetisme, drijfkracht etc. etc.

Al deze krachten ontstaan op andere manier, hoewel enkele nauw verwant aan elkaar zijn. Voor een aantal van deze krachten zijn formules opgesteld waarmee ze berekend kunnen worden. Zo geldt bij zwaartekracht, veerkracht en dempkracht bijvoorbeeld dat:

Bij constante g:
	Fz = M * g
Fz = zwaartekracht (in N)
M: massa (in kilogram)
g = gravitatie (in m/(s^2))

Bij constante l:
	Fv = k * (l - lr)
Fv = veerkracht (in N)
k = krachtconstante (in N/m)
l = lengte van de veer (in m)
lr = lengte van de veer bij rust (in m)

Bij constante V:
	Fd = -c * V
Fd = dempkracht (in N)
c = dempingconstante (in Ns/m)
V: snelheid (in m/s)


Om de kracht die deze soorten krachten genereren uit te rekenen zijn maar enkele redelijk eenvoudig te vinden parameters nodig: bij zwaartekracht word de massa van de particle gebruikt, en een constante gravitatie. Voor de veerkracht wordt de veerkrachtconstante, een getal dat de rustlengte van de veer bepaalt en de lengte van de veer (die weer met pythagoras en de posities berekent kan worden) gebruikt. Krachten zoals deze zijn exact uit te rekenen voor elk moment. Omdat deze krachten (binnen de limieten van computers) exact uitgerekend kunnen worden met alleen bekende variabelen zullen deze krachten voor de rest van dit artikel 'deterministische krachten' genoemd worden.


Normaalkracht en verwante krachten (zoals hydraulische druk en drijfkracht) zijn echter niet deterministisch. Deze soort krachten ontstaan namelijk om een correcte staat te handhaven (meerdere objecten mogen niet de zelfde ruimte innemen bijvoorbeeld). Dit betekent dat de kracht niet direct gevonden kan worden: eerst moeten alle andere krachten bekend zijn, waarna berekent kan worden welke kracht daar tegenover gezet moet worden om een correcte staat te handhaven. Als een object echter onderhevig is het exact uitrekenen van de krachten logischerwijs niet mogelijk aangezien beide krachten kennis over de andere nodig hebben om een volledig resultaat te kunnen leveren.

Omdat al bleek dat de krachten het gevolg zijn van het handhaven van een correcte staat kunnen we het probleem ook anders aanpakken; Eerst verplaatsten we de particles door alle 'deterministische krachten' en de beginsnelheid toe te passen (dit noemen we projecteren projecteren). Daarna benaderen we een correcte staat zonder de normaalkrachten uit te rekenen. De posities die de particles na deze operatie hebben is resultaat van zowel de deterministische krachten als van de normaalkrachten, dus gelijk aan de eindpositie (S1). Omdat we uitgaan van een constante a kunnen we V1 berekenen met de volgende formules:

Bij constante a:
	S1 = S0 + V0 * t + 1/2 * a * t^2
S1: huidige positie (in m)
S0: vorige positie (in m)
V0: vorige snelheid (in m/s)
t: tijdsinterval (in s)
a: acceleratie (in m/s^2)

Bij constante a:
	V1 = V0 + a * t
V: snelheid (in m/s)
a: acceleratie

We schrijven de eerste formule om naar een formule die a als resultaat geeft:

bij constante a:
	a = 2  * (S1 - S0 - V0 * t) / t^2
a: acceleratie (in m/s^2)
S1: huidige positie (in m)
S0: vorige positie (in m)
V0: vorige snelheid (in m/s)
t: tijdsinterval (in s)

Nu kunnen we deze substitueren in de tweede formule, na vereenvoudiging geeft dit:

bij constante a:
	V1 = 2 * (S1 - S0) / t - V0	

Dit betekent dat we S1 en V1 uit kunnen rekenen zonder dat de acceleraties bekend hoeven te zijn, zolang we de eindposities (S1) kunnen benaderen.

Om de normaalkrachten te kunnen handhaven hebben we eerst een systeem nodig om duidelijk te kunnen bepalen of een staat 'correct' is (dit systeem is gescheiden van het systeem dat de deterministische krachten beschrijft). Dit doen we door relaties tussen particles op te stellen die we 'constraints' of 'beperkingen' noemen. Een constraint omschrijft een eigenschap van de staat van de particles die gehandhaafd moet blijven. Een voorbeeld van een constraint is een afstandsconstraint: om te zorgen dat twee particles niet te dicht bij elkaar komen kunnen we bepalen dat de afstand tussen twee particles niet kleiner mag worden dan een bepaalde waarde die voor de constraint bepaald is. Als de afstand kleiner wordt dan deze waarde beschouwen we de constraint als geschonden. Afstandsconstraints kunnen ook voorkomen in andere vormen, bijvoorbeeld een afstandsconstraint waar de afstand gelijk moet zijn aan een bepaalde waarde. Deze worden gebruikt om de relaties tussen particles in een object vast te stellen, aangezien deze samengedrukt mogen worden, maar ook niet uit elkaar getrokken mogen worden.

Om dit probleem goed op te lossen is het praktisch om uit te kunnen rekenen hoe 'incorrect' een bepaalde staat is. Als we de constraints op willen lossen proberen we deze waarde dus te verlagen. We definieren de fout (E) van een constraint als de massa van de particles maal de afstand die deze particles af moeten leggen om de constraint te handhaven:

Bij n particles:
	E = dS1 * m1 + dS2 * m2 + ...  + dS(n-1) * m(n-1) + dSn * mn
E: fout (in m*kg)
dSn: benodigde verandering van positie van particle n (in m)
mn: massa van particle n (in kg)

Omdat er veel verschillende soorten constraints mogelijk zijn is het helaas niet mogelijk om een alomvattende algoritme (formules volstaan niet om deze waarden uit te rekenen) te geven die de fout van een constraint levert. Toch zal ik ter illustratie zal ik een voorbeeld geven; een algoritme die de fout geeft van een afstandsconstraint waar de afstand tussen twee particles exact gelijk moet zijn aan de waarde d:

	E = 2 * ||S1 - S2| - d| * m1 / (1 + m1 / m2)
E: fout (in m)
d: afstand die de particles minimaal tot elkaar horen te hebben (in m)
|Sn - Sn2|: de afstand tussen particle n en particle n2 (in m)
mn: de massa van particle n (in kg)

//leg ook m1 * S1 = m2 * S2 uit (hoe de formule is opgestelt)? <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Het volgende algoritme is voor een afstandsconstraint waar de afstand tussen twee particles groter moet zijn dan de waarde d:

	if (|Sn - Sn2| > d) {
		E = 0
	} else {
		E = 2 * ||S1 - S2| - d| * m1 / (1 + m1 / m2)
	}
E: fout (in m)
d: afstand die de particles minimaal tot elkaar horen te hebben (in m)
|Sn - Sn2|: de afstand tussen particle n en particle n2 (in m)
mn: de massa van particle n (in kg)

Aan dit voorbeeld is goed te zien waarom een normale formule niet altijd volstaat om E uit te rekenen; zolang de onderlinge afstand tussen de particles groter is dan d is de constraint gehandhaafd, en is het resultaat 0 (want er is geen fout). Als de onderlinge afstand echter kleiner is dan d is er wel sprake van een fout. Merk ook op dat de waarde van E altijd voldoet aan E >= 0.

Nu gaan we proberen te zorgen dat alle constraints gehandhaafd worden. Het is echter belangrijk dat constraints niet en één keer gehandhaafd worden, anders zouden we er namelijk impliciet van uitgegaan worden dat de invloed van constraints op elkaar verwaarloost kan worden. Vaak is het echter zo dat meerdere particles een constraint delen, en dat beide zo constraints veel invloed op elkaar hebben. Om dit probleem op te lossen worden alle constraints gedeeltelijk gehandhaaft, door het gedeeltelijk handhaven te herhalen word de fout steeds vermindert. Om te zorgen dat alle constraints evenveel prioriteit krijgen word de fout van een constraint vermenigvuldigd met een factor (f) die voor alle constraints gelijk is, om te bepalen hoever een constraint opgelost moet worden:

//vertel ook over lim E -> 0 ? <<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	Er = E * f
Er: hoeveel de fout van de constraint verminderd moet worden (in m*kg)
E: fout van de constraint (in m*kg)
f: factor (zonder eenheid) die voldoet aan 0 < f <= 1


Nu kan de verplaatsing van de particles berekent worden met:

	vector relativePosition = S2 - S1;
	//vector pointing from particle1 to particle2 with unit length
	
	float distance = |relativePosition|
	relativePosition = relativePosition / |relativePosition|
	
	float displacement1;
	float displacement2;
	//floats representing how far both vectors have to be moved outward
	
	if (distance < length) {
		displacement1 = 0.5 * Er / m1
		displacement2 = 0.5 * Er / m2
	} else {
		displacement1 = - 0.5 * Er / m1
		displacement2 = - 0.5 * Er / m2
	}
	
	dS1 = -1 * relativePosition * displacement1
	dS2 = +1 * relativePosition * displacement2




//Merk dat bij het opstellen van dit algoritme gebruik gemaakt is van de wetten F = M * a ^ F1 = -F2 ^ Sdelta = 1/2 * a * t^2. Deze wetten worden dus door de constraint toegepast.


Globale werking:
Onderweg zijn een paar gedeeltes veranderd, dus ik zal een keer de uiteindelijke, globale werking uitleggen. Naast de oorspronkelijke snelheid en positie van de particles hebben we de acceleratie van de particles nodig om iets over de eindpositie te kunnen zeggen. De acceleratie word bepaalt door de totale kracht op de particles, wat op zijn beurt de som is van alle individuele krachten die op de particle werken. Al deze krachten moeten dus benaderd worden. Omdat er een groot verschil zit tussen twee groepen krachten (deterministische krachten & constriants) moet het benaderen van de nieuwe positie in twee stappen verdeeld worden; eerst worden de deterministische krachten bepaalt, en worden toegepast op de posities van de particles samen met de beginsnelheid. Daarna worden de constraints toegepast. Dit gebeurt door alle constriants voor een bepaald gedeelte op te lossen, en dit te herhalen. Bij elke herhaling daalt fout in de constriants. We weten nu de positie van de particles nadat de oorspronkelijke snelheid, de deterministische krachten, en de constraints toegepast zijn. Dit is onze eindpositie. Voor de volgende simulatie moet echter een beginsnelheid vastgesteld worden, deze kan berekend worden aan de hand van de beginsnelheid, beginpositie, en de eindsnelheid.
